---
title: How to Measure Performance
description: "Learn about the performance impact of a datapack."
version: 1.21.8
---

# How to Measure Performance

Datapacks are server side - they run on the server. The "server" is the brain of
the world. It handles all the logic of the world. 

- Generating new chunks as players explore the world.

- Validating player interactions such as mining blocks.

- Mob behaviour. All mob AI, pathfinding, targeting, etc.

- And so on...

Server performance is measured in [TPS](https://minecraft.wiki/w/Tick#Game_tick) - ticks per second.
Server updates the game state every tick. Calculates mobs' positions and state,
validating player actions like breaking and placing blocks, and processes all
other game logic.

Server normally runs at 20 TPS. However, if the server is overloaded with
computations - it makes the individual tick longer, to keep up with all the
computations. That leads to lower TPS, which causes lag and delay for all
players. Blocks disappearing, or breaking too slowly, mobs behaviour slowing
down, this is all due to low TPS.

## Measure Overall Performance

You can toggle the [TPS graph](https://minecraft.wiki/w/Debug_screen#TPS_graph) using `F3 + 2`. 

![TPS graph showcase](https://i.postimg.cc/L4Bx7N4M/Cn-P-05082025-214044.png)

Graph shows the last 240 ticks, each tick represented as a thin colored line.
There are a total of 4 possible colors, stacked onto each other like layers.
Each color serves it's own purpose.

- **Layer 1** Dark red is time spent for the main logic of the tick. Bottom layer.

- **Layer 2** Light brown is time spent running [scheduled tasks](https://minecraft.wiki/w/Tick#Scheduled_tick).

- **Layer 3** Purple is time spent executing all other code.

- **Layer 4** Green / Yellow / Red (depending on lag) is time spent waiting for the next tick. Top layer.

Then, on top of the graph you can see 3 numbers: min, avg, max. They show the
how much time in milliseconds it took to compute for the shortest, average and
longest tick, currently visible on the graph.

If the longest tick (max) on the graph took less than 50ms (length of a single
tick) the TPS is good. The server is able to process all logic in time. Otherwise,
if max is above 50 and the lines high enough to cross over the border, the TPS is
suffering.

## Benchmarking

Benchmarking is also a way of measuring performance. However, unlike the TPS
graph, benchmarking measures the performance of a specific chunk of code in a
datapack, rather than general performance of the server. 

Benchmarking results are inconsistent across PCs due to different hardware
specifications. However, the difference in results between two different
benchmarks is usually somewhat consistent, even across different PCs. This is
why benchmarking is generally used for comparing the performance of different
implementations.

### How Benchmarking Works

:::info
A recursive function is a function that runs itself repeatedly. A single
recursive function call is called an iteration.
:::

Benchmarkng works by running the same function recursively, as many times as
possible, for 40ms every tick.

High level overview of the implementation:

- Move world border by a 1000 blocks in 1 second.

- Start recursively running the function, until the world border has moved by 40
blocks

- Repeat this cycle for a 100 more ticks (5 seconds)

Then, measure the average amount of iterations across the 100 ticks. This works,
because world border movement does not depend on ticks, and moves in real time.

### Benchmark Tools

While you could write your own benchmark,
we recommend using [Kragast's Benchmark](https://www.planetminecraft.com/data-pack/benchmark-6443027/) datapack,
since it makes benchmarking easier.

The following section will explain how to
use Kragast's Benchmark datapack using an example. This datapack measures the
performance of a function by running it repeatedly as many times as possible
before the game starts to lag. The more times your function ran - the more
performant it is.

To start, download the datapack, unzip, and open it. In the function folder
under the `benchmark` namespace you will notice a few functions for you to use.

 ðŸ“„ `config.mcfunction`  ðŸ“„ `order.mcfunction`

Functions above are used to customize the behavior of the benchmark datapack.
There are many settings, every option is documented within the `config` function
using comments. For this example, the default settings are good enough so we
will not change anything.

 ðŸ“„ `test.mcfunction`  ðŸ“„ `test2.mcfunction`

Functions above will both be running repeatedly to test their performance.
For this example, let's compare a scoreboard check with an entity NBT check.
But you can write your own tests, and compare anything you want. First, create a
bunch of armor_stand entities in an empty world. Then put the following code in
`test` and `test2` functions.

```mcfunction:test.mcfunction
execute as @e[type=armor_stand] if score @s test matches 1.. 
```

```mcfunction:test2.mcfunction
execute as @e[type=armor_stand] if data entity @s {ShowArms:false}
```

Now, all that is left is to run `function #benchmark:get_profile` and wait for
the result.

### Reading Results

![Benchmark Results](https://i.postimg.cc/1zMR54Fz/Cn-P-05082025-232103.png)

With the previously mentioned setup, and a total of 300 armor stands in the
world, these are the results i ended up with. Yellow number is the amount of
time a function was ran. Bigger number - faster execution, better performance.

- **Function 0:** This is the control function. It is always empty, and is only
  here to provide a baseline to compare to.

- **Function 1:** This is the `test` function, the one with scoreboard check.

- **Function 2:** This is the `test2` function, the one with entity NBT check.

Since the `test` function executed more frequently, it has better
performance compared to `test2`.
